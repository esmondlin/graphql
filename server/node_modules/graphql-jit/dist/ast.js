"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const execute_1 = require("graphql/execution/execute");
const language_1 = require("graphql/language");
const type_1 = require("graphql/type");
const util_1 = require("util");
/**
 * Given a selectionSet, adds all of the fields in that selection to
 * the passed in map of fields, and returns it at the end.
 *
 * CollectFields requires the "runtime type" of an object. For a field which
 * returns an Interface or Union type, the "runtime type" will be the actual
 * Object type returned by that field.
 */
function collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {
    for (const selection of selectionSet.selections) {
        switch (selection.kind) {
            case language_1.Kind.FIELD:
                if (!shouldIncludeNode(exeContext, selection)) {
                    continue;
                }
                const name = getFieldEntryKey(selection);
                if (!fields[name]) {
                    fields[name] = [];
                }
                fields[name].push(selection);
                break;
            case language_1.Kind.INLINE_FRAGMENT:
                if (!shouldIncludeNode(exeContext, selection) ||
                    !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {
                    continue;
                }
                collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
                break;
            case language_1.Kind.FRAGMENT_SPREAD:
                const fragName = selection.name.value;
                if (visitedFragmentNames[fragName] ||
                    !shouldIncludeNode(exeContext, selection)) {
                    continue;
                }
                visitedFragmentNames[fragName] = true;
                const fragment = exeContext.fragments[fragName];
                if (!fragment ||
                    !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {
                    continue;
                }
                collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
                break;
        }
    }
    return fields;
}
exports.collectFields = collectFields;
/**
 * Determines if a field should be included based on the @include and @skip
 * directives, where @skip has higher precedence than @include.
 */
function shouldIncludeNode(exeContext, node) {
    const skip = graphql_1.getDirectiveValues(graphql_1.GraphQLSkipDirective, node, exeContext.variableValues);
    if (skip && skip.if === true) {
        return false;
    }
    const include = graphql_1.getDirectiveValues(graphql_1.GraphQLIncludeDirective, node, exeContext.variableValues);
    if (include && include.if === false) {
        return false;
    }
    return true;
}
/**
 * Determines if a fragment is applicable to the given type.
 */
function doesFragmentConditionMatch(exeContext, fragment, type) {
    const typeConditionNode = fragment.typeCondition;
    if (!typeConditionNode) {
        return true;
    }
    const conditionalType = graphql_1.typeFromAST(exeContext.schema, typeConditionNode);
    if (conditionalType === type) {
        return true;
    }
    if (!conditionalType) {
        return false;
    }
    if (type_1.isAbstractType(conditionalType)) {
        return exeContext.schema.isPossibleType(conditionalType, type);
    }
    return false;
}
/**
 * Implements the logic to compute the key of a given field's entry
 */
function getFieldEntryKey(node) {
    return node.alias ? node.alias.value : node.name.value;
}
/**
 * Resolves the field on the given source object. In particular, this
 * figures out the value that the field returns by calling its resolve function,
 * then calls completeValue to complete promises, serialize scalars, or execute
 * the sub-selection-set for objects.
 */
function resolveFieldDef(exeContext, parentType, fieldNodes) {
    const fieldNode = fieldNodes[0];
    const fieldName = fieldNode.name.value;
    return execute_1.getFieldDef(exeContext.schema, parentType, fieldName);
}
exports.resolveFieldDef = resolveFieldDef;
/**
 * A memoized collection of relevant subfields in the context of the return
 * type. Memoizing ensures the subfields are not repeatedly calculated, which
 * saves overhead when resolving lists of values.
 */
exports.collectSubfields = memoize3(_collectSubfields);
function _collectSubfields(exeContext, returnType, fieldNodes) {
    let subFieldNodes = Object.create(null);
    const visitedFragmentNames = Object.create(null);
    for (const fieldNode of fieldNodes) {
        const selectionSet = fieldNode.selectionSet;
        if (selectionSet) {
            subFieldNodes = collectFields(exeContext, returnType, selectionSet, subFieldNodes, visitedFragmentNames);
        }
    }
    return subFieldNodes;
}
function memoize3(fn) {
    let cache0;
    function memoized(a1, a2, a3) {
        if (!cache0) {
            cache0 = new WeakMap();
        }
        let cache1 = cache0.get(a1);
        let cache2;
        if (cache1) {
            cache2 = cache1.get(a2);
            if (cache2) {
                const cachedValue = cache2.get(a3);
                if (cachedValue !== undefined) {
                    return cachedValue;
                }
            }
        }
        else {
            cache1 = new WeakMap();
            cache0.set(a1, cache1);
        }
        if (!cache2) {
            cache2 = new WeakMap();
            cache1.set(a2, cache2);
        }
        const newValue = fn(...arguments);
        cache2.set(a3, newValue);
        return newValue;
    }
    return memoized;
}
/**
 * Prepares an object map of argument values given a list of argument
 * definitions and list of argument AST nodes.
 *
 * Note: The returned value is a plain Object with a prototype, since it is
 * exposed to user code. Care should be taken to not pull values from the
 * Object prototype.
 */
function getArgumentDefs(def, node) {
    const values = {};
    const missing = {};
    const argDefs = def.args;
    const argNodes = node.arguments;
    if (!argDefs || !argNodes) {
        return { values, missing };
    }
    const argNodeMap = keyMap(argNodes, arg => arg.name.value);
    for (const argDef of argDefs) {
        const name = argDef.name;
        const argType = argDef.type;
        const argumentNode = argNodeMap[name];
        if (argumentNode && argumentNode.value.kind === language_1.Kind.VARIABLE) {
            missing[name] = argumentNode.value.name.value;
        }
        else if (argumentNode) {
            const coercedValue = graphql_1.valueFromAST(argumentNode.value, argType, {});
            if (coercedValue === undefined) {
                // Note: ValuesOfCorrectType validation should catch this before
                // execution. This is a runtime check to ensure execution does not
                // continue with an invalid argument value.
                throw new graphql_1.GraphQLError(`Argument "${name}" of type \"${argType}\" has invalid value ${graphql_1.print(argumentNode.value)}.`, [argumentNode.value]);
            }
            values[name] = coercedValue;
        }
        if (argDef.defaultValue !== undefined && values[name] === undefined) {
            // If no argument was provided where the definition has a default value,
            // use the default value.
            values[name] = argDef.defaultValue;
        }
        if (graphql_1.isNonNullType(argType) &&
            values[name] === undefined &&
            missing[name] === undefined) {
            // If no value or a nullish value was provided to a variable with a
            // non-null type (required), produce an error.
            throw new graphql_1.GraphQLError(argumentNode
                ? `Argument "${name}" of non-null type ` +
                    `"${argType}" must not be null.`
                : `Argument "${name}" of required type ` +
                    `"${argType}" was not provided.`, [node]);
        }
    }
    return { values, missing };
}
exports.getArgumentDefs = getArgumentDefs;
/**
 * Creates a keyed JS object from an array, given a function to produce the keys
 * for each value in the array.
 *
 * This provides a convenient lookup for the array items if the key function
 * produces unique results.
 *
 *     const phoneBook = [
 *       { name: 'Jon', num: '555-1234' },
 *       { name: 'Jenny', num: '867-5309' }
 *     ]
 *
 *     // { Jon: { name: 'Jon', num: '555-1234' },
 *     //   Jenny: { name: 'Jenny', num: '867-5309' } }
 *     const entriesByName = keyMap(
 *       phoneBook,
 *       entry => entry.name
 *     )
 *
 *     // { name: 'Jenny', num: '857-6309' }
 *     const jennyEntry = entriesByName['Jenny']
 *
 */
function keyMap(list, keyFn) {
    return list.reduce((map, item) => ((map[keyFn(item)] = item), map), Object.create(null));
}
/**
 * Prepares an object map of variableValues of the correct type based on the
 * provided variable definitions and arbitrary input. If the input cannot be
 * parsed to match the variable definitions, a GraphQLError will be thrown.
 */
function getVariableValues(schema, varDefNodes, inputs) {
    const errors = [];
    const coercedValues = Object.create(null);
    for (const varDefNode of varDefNodes) {
        const varName = varDefNode.variable.name.value;
        const varType = graphql_1.typeFromAST(schema, varDefNode.type);
        if (!varType || !graphql_1.isInputType(varType)) {
            // Must use input types for variables. This should be caught during
            // validation, however is checked again here for safety.
            errors.push(new graphql_1.GraphQLError(`Variable "$${varName}" expected value of type ` +
                `"${varType ? varType : graphql_1.print(varDefNode.type)}" which cannot be used as an input type.`, [varDefNode.type]));
        }
        else {
            const hasValue = hasOwnProperty(inputs, varName);
            const value = hasValue ? inputs[varName] : undefined;
            if (!hasValue && varDefNode.defaultValue) {
                // If no value was provided to a variable with a default value,
                // use the default value.
                coercedValues[varName] = graphql_1.valueFromAST(varDefNode.defaultValue, varType);
            }
            else if ((!hasValue || value === null) && graphql_1.isNonNullType(varType)) {
                // If no value or a nullish value was provided to a variable with a
                // non-null type (required), produce an error.
                errors.push(new graphql_1.GraphQLError(hasValue
                    ? `Variable "$${varName}" of non-null type ` +
                        `"${varType}" must not be null.`
                    : `Variable "$${varName}" of required type ` +
                        `"${varType}" was not provided.`, [varDefNode]));
            }
            else if (hasValue) {
                if (value === null) {
                    // If the explicit value `null` was provided, an entry in the coerced
                    // values must exist as the value `null`.
                    coercedValues[varName] = null;
                }
                else {
                    // Otherwise, a non-null value was provided, coerce it to the expected
                    // type or report an error if coercion fails.
                    const coerced = graphql_1.coerceValue(value, varType, varDefNode);
                    const coercionErrors = coerced.errors;
                    if (coercionErrors) {
                        coercionErrors.forEach((error) => {
                            error.message =
                                `Variable "$${varName}" got invalid ` +
                                    `value ${util_1.inspect(value)}; ${error.message}`;
                        });
                        errors.push(...coercionErrors);
                    }
                    else {
                        coercedValues[varName] = coerced.value;
                    }
                }
            }
        }
    }
    return errors.length === 0
        ? { errors: undefined, coerced: coercedValues }
        : { errors, coerced: undefined };
}
exports.getVariableValues = getVariableValues;
function computeLocations(nodes) {
    if (!Array.isArray(nodes) || !nodes.length) {
        return undefined;
    }
    const locations = nodes.reduce((list, node) => {
        if (node.loc) {
            list.push(graphql_1.getLocation(node.loc.source, node.loc.start));
        }
        return list;
    }, []);
    if (locations.length === 0) {
        return undefined;
    }
    return locations;
}
exports.computeLocations = computeLocations;
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
//# sourceMappingURL=ast.js.map