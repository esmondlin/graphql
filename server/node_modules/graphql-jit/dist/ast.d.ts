import { DirectiveNode, FieldNode, GraphQLDirective, GraphQLField, GraphQLObjectType, GraphQLSchema, SelectionSetNode, SourceLocation, VariableDefinitionNode } from "graphql";
import { ExecutionContext } from "graphql/execution/execute";
import { CoercedVariableValues } from "graphql/execution/values";
import Maybe from "graphql/tsutils/Maybe";
/**
 * Given a selectionSet, adds all of the fields in that selection to
 * the passed in map of fields, and returns it at the end.
 *
 * CollectFields requires the "runtime type" of an object. For a field which
 * returns an Interface or Union type, the "runtime type" will be the actual
 * Object type returned by that field.
 */
export declare function collectFields(exeContext: ExecutionContext, runtimeType: GraphQLObjectType, selectionSet: SelectionSetNode, fields: {
    [key: string]: FieldNode[];
}, visitedFragmentNames: {
    [key: string]: boolean;
}): {
    [key: string]: FieldNode[];
};
/**
 * Resolves the field on the given source object. In particular, this
 * figures out the value that the field returns by calling its resolve function,
 * then calls completeValue to complete promises, serialize scalars, or execute
 * the sub-selection-set for objects.
 */
export declare function resolveFieldDef(exeContext: ExecutionContext, parentType: GraphQLObjectType, fieldNodes: FieldNode[]): Maybe<GraphQLField<any, any>>;
/**
 * A memoized collection of relevant subfields in the context of the return
 * type. Memoizing ensures the subfields are not repeatedly calculated, which
 * saves overhead when resolving lists of values.
 */
export declare const collectSubfields: (exeContext: ExecutionContext, returnType: GraphQLObjectType, fieldNodes: FieldNode[]) => {
    [key: string]: FieldNode[];
};
export interface Arguments {
    values: {
        [argument: string]: any;
    };
    missing: {
        [argument: string]: any;
    };
}
/**
 * Prepares an object map of argument values given a list of argument
 * definitions and list of argument AST nodes.
 *
 * Note: The returned value is a plain Object with a prototype, since it is
 * exposed to user code. Care should be taken to not pull values from the
 * Object prototype.
 */
export declare function getArgumentDefs(def: GraphQLField<any, any> | GraphQLDirective, node: FieldNode | DirectiveNode): Arguments;
/**
 * Prepares an object map of variableValues of the correct type based on the
 * provided variable definitions and arbitrary input. If the input cannot be
 * parsed to match the variable definitions, a GraphQLError will be thrown.
 */
export declare function getVariableValues(schema: GraphQLSchema, varDefNodes: ReadonlyArray<VariableDefinitionNode>, inputs: {
    [key: string]: any;
}): CoercedVariableValues;
export declare function computeLocations(nodes: FieldNode[]): SourceLocation[] | undefined;
