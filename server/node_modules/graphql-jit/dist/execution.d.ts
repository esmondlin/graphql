import { DocumentNode, ExecutionResult, GraphQLError, GraphQLObjectType, GraphQLOutputType, GraphQLScalarSerializer, GraphQLSchema } from "graphql";
import { ExecutionContext } from "graphql/execution/execute";
import { FieldNode } from "graphql/language/ast";
import Maybe from "graphql/tsutils/Maybe";
import { Arguments } from "./ast";
export interface CompilerOptions {
    customJSONSerializer: boolean;
    disableLeafSerialization: boolean;
    customSerializers: {
        [key: string]: (v: any) => any;
    };
}
/**
 * The context used during compilation.
 *
 * It stores deferred nodes to be processed later as well as the function arguments to be bounded at top level
 */
interface CompilationContext extends ExecutionContext {
    dependencies: Map<string, (...args: any[]) => any>;
    deferred: DeferredField[];
    options: CompilerOptions;
    depth: number;
}
declare type ResponsePathType = "variable" | "literal" | "meta";
interface ResponsePath {
    prev: ResponsePath | undefined;
    key: string;
    type: ResponsePathType;
}
interface DeferredField {
    name: string;
    responsePath: ResponsePath;
    originPaths: string[];
    destinationPaths: string[];
    parentType: GraphQLObjectType;
    fieldName: string;
    fieldType: GraphQLOutputType;
    fieldNodes: FieldNode[];
    args: Arguments;
}
export declare type Callback = (d: object | null, e: Error | null) => void;
export declare type JITCallback = (p: object, d: object | null, e: Error | null) => void;
export interface CompiledQuery {
    operationName?: string;
    query: (root: any, context: any, variables: Maybe<{
        [key: string]: GraphQLScalarSerializer<any>;
    }>) => Promise<ExecutionResult> | ExecutionResult;
    stringify: (v: any) => string;
}
/**
 * It compiles a GraphQL query to an executable function
 * @param {GraphQLSchema} schema GraphQL schema
 * @param {DocumentNode} document Query being submitted
 * @param {string} operationName name of the operation
 * @param partialOptions compilation options to tune the compiler features
 * @returns {CompiledQuery} the cacheable result
 */
export declare function compileQuery(schema: GraphQLSchema, document: DocumentNode, operationName?: string, partialOptions?: Partial<CompilerOptions>): CompiledQuery | ExecutionResult;
export declare function isCompiledQuery<C extends CompiledQuery, E extends ExecutionResult>(query: C | E): query is C;
export declare function createBoundQuery(context: CompilationContext, document: DocumentNode, func: (...args: any[]) => any): (rootValue: any, context: any, variables: Maybe<{
    [key: string]: any;
}>) => ExecutionResult<import("graphql/execution/execute").ExecutionResultDataDefault> | Promise<ExecutionResult<import("graphql/execution/execute").ExecutionResultDataDefault>>;
export declare function isPromise(value: any): value is Promise<any>;
/**
 * Handles the book keeping of running promises
 * loosely and returning a final callback.
 *
 * The final callback is called after every possible promise has returned.
 *
 * Exported only for tests.
 *
 * @param finalCb callback to be called once the all promises have been resolved
 * @param {(err: Error) => void} errorHandler global error handler in case of bugs in the runtime
 * @returns an object with two function, a execute function and checker when everything is resolved
 */
export declare function loosePromiseExecutor(finalCb: (data: object, errors: GraphQLError[], nullErrors: GraphQLError[]) => void, errorHandler: (err: Error) => void): {
    executor: (resolver: () => Promise<any>, cb: JITCallback, parent: object, data: object, errors: GraphQLError[], nullErrors: GraphQLError[]) => void;
    resolveIfDone: (data: object, errors: GraphQLError[], nullErrors: GraphQLError[]) => void;
};
/**
 * Handles the book keeping of running the top level promises serially.
 * The serial phase places all units of work in a queue which
 * is only started once startExecution is triggered.
 *
 * From then on, any new work is executed with the parallel executor.
 * New work is executed within the lifespan of the top level promise.
 * Once all promises are over, the executor will move on to the next serial
 * piece of work.
 *
 * The final callback is called after every possible promise has returned.
 *
 * Exported only for tests.
 *
 * @param finalCb callback to be called once the all promises have been resolved
 * @param {(err: Error) => void} errorHandler global error handler in case of bugs in the runtime
 * @returns an object with two function, a execute function to submit work and
 * startExecution to trigger the execution of everything submitted so far.
 */
export declare function serialPromiseExecutor(finalCb: (data: object, errors: GraphQLError[], nullErrors: GraphQLError[]) => void, errorHandler: (err: Error) => void): {
    addToQueue: (resolver: () => Promise<any>, cb: JITCallback, parent: object, data: object, errors: GraphQLError[], nullErrors: GraphQLError[]) => void;
    startExecution: (data: object, errors: GraphQLError[], nullErrors: GraphQLError[]) => void;
};
export {};
